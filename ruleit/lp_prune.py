from rdkit import Chem as chem
from rdkit.Chem import rdChemReactions as rdr
from pulp import *

def neutralize_atoms(mol: chem.rdchem.Mol):
    """
    copied from 
    https://www.rdkit.org/docs/Cookbook.html
    
    """
    pattern = chem.MolFromSmarts("[+1!h0!$([*]~[-1,-2,-3,-4]),-1!$([*]~[+1,+2,+3,+4])]")
    at_matches = mol.GetSubstructMatches(pattern)
    at_matches_list = [y[0] for y in at_matches]
    if len(at_matches_list) > 0:
        for at_idx in at_matches_list:
            atom = mol.GetAtomWithIdx(at_idx)
            chg = atom.GetFormalCharge()
            hcount = atom.GetTotalNumHs()
            atom.SetFormalCharge(0)
            atom.SetNumExplicitHs(hcount - chg)
            atom.UpdatePropertyCache()
    return mol


def smiles_to_inchikey(smiles):
    mol = chem.MolFromSmiles(smiles, sanitize=False)
    chem.RemoveStereochemistry(mol)
    mol = neutralize_atoms(mol)
    return chem.MolToInchiKey(mol)[:-2]

def smiles_to_smiles(smiles):
    mol = chem.MolFromSmiles(smiles, sanitize=False)
    chem.RemoveStereochemistry(mol)
    mol = neutralize_atoms(mol)
    return chem.MolToSmiles(mol)


def mol_to_inchikey(mol):
    chem.RemoveStereochemistry(mol)
    mol = neutralize_atoms(mol)
    return chem.MolToInchiKey(mol)[:-2]

def split_reaction_string(reaction):
    reaction = rdr.ReactionFromSmarts(reaction['smiles'], useSmiles=True)
    #reactants, products = reaction['smiles'].split('>>')
    reactants = list(map(mol_to_inchikey, reaction.GetReactants()))
    products = list(map(mol_to_inchikey, reaction.GetProducts()))
    return reactants, products

def extract_molecules(reactions):
    molecules = []
    for reaction in reactions:
        mr, mp = reaction['smiles'].split('>>')
        mr = mr.split('.')
        mp = mp.split('.')
        for m in filter(lambda x: x not in molecules, mr + mp):
            molecules.append(smiles_to_smiles(m))
    return molecules


def process_reaction(reaction, reaction_name, 
                     molecule_reaction_map_reactant, molecule_reaction_map_product):

    
    reactants, products =  split_reaction_string(reaction)
    
    for r in filter(lambda x: x != "", reactants):
        try:
            molecule_reaction_map_reactant[r].append(reaction_name)
        except KeyError:
            molecule_reaction_map_reactant[r] = [reaction_name]

        

    for p in filter(lambda x: x != "", products):
        try:
            molecule_reaction_map_product[p].append(reaction_name)
        except KeyError:
            molecule_reaction_map_product[p] = [reaction_name]

    return None

    

def create_matrix(reactions, imports, exports):
    molecule_reaction_map_reactant = dict()
    molecule_reaction_map_product = dict()
    
    
    for i, reaction in enumerate(reactions):
        reaction_name = reaction['reaction_id']
        process_reaction(reaction, reaction_name, molecule_reaction_map_reactant, molecule_reaction_map_product)
    for i, reaction in enumerate(imports):
        reaction_name = 'i{:06d}'.format(i)
        process_reaction(reaction, reaction_name, molecule_reaction_map_reactant, molecule_reaction_map_product)
    for i, reaction in enumerate(exports):
        reaction_name = 'e{:06d}'.format(i)
        process_reaction(reaction, reaction_name, molecule_reaction_map_reactant, molecule_reaction_map_product)

    return molecule_reaction_map_reactant, molecule_reaction_map_product


def filter_hits(reactions, hits):
    """
    This function prunes the hits to match the compounds that can
    be generated by the network.
    """
    reaction_molecules = extract_molecules(reactions)

    reaction_molecules = list(map(smiles_to_inchikey, reaction_molecules))
    hits_df = []
    for h in hits:
        hits_df.append(
            dict(smiles=h, inchikey=smiles_to_inchikey(h))
        )

    hits_df = [h for h in hits_df if h['inchikey'] in reaction_molecules]
    return hits_df


def lp_prune(reactions, seeds, hits):
    molecules = extract_molecules(reactions)
    import_reactions = [{"smiles": f">>{smiles_to_smiles(s)}"} for s in seeds]
    export_reactions = [{"smiles": f"{smiles_to_smiles(h)}>>"} for h in molecules]
    hits = list(map(lambda x: smiles_to_inchikey(x), hits))
    
    reaction_dict = dict()
    out_reactions = dict()
    
    for i, r in enumerate(reactions):
        idx = r['reaction_id']
        reaction_dict[idx] = LpVariable(idx, 0, None, LpContinuous)
        out_reactions[idx] = r
    for i, s in enumerate(import_reactions):
        idx = 'i{:06d}'.format(i)
        reaction_dict[idx] = LpVariable(idx, 0, None, LpContinuous)
        out_reactions[idx] = s
    for i, (m, r) in enumerate(zip(molecules, export_reactions)):
        idx = 'e{:06d}'.format(i)
        
        m = smiles_to_inchikey(m)
        
        if m in hits:
            reaction_dict[idx] = LpVariable(idx, 0.01, None, LpContinuous)
            out_reactions[idx] = r
        else:
            reaction_dict[idx] = LpVariable(idx, 0.0, None, LpContinuous)
            out_reactions[idx] = r

    prob = LpProblem('MSP-Formose', LpMinimize)
    Mr, Mp = create_matrix(reactions, import_reactions, export_reactions)


    for m in molecules:
        m = smiles_to_inchikey(m)
        try:
            product_of = Mr[m]
        except KeyError:
            product_of = []
        try:
            reactant_of = Mp[m]
        except KeyError:
            reactant_of = []
        prob += lpSum(
            [(1.0 * reaction_dict[x]) for x in product_of] + 
            [(-1.0 * reaction_dict[x]) for x in reactant_of]
        ) == 0.0

    prob += lpSum([(1.0 * reaction) for key, reaction in reaction_dict.items() if key[0] == 'r'])
    prob.solve()
    for r in prob.variables():
        out_reactions[r.name]['active'] = (r.varValue != 0.0)
    return prob.sol_status, out_reactions

# for v in prob.variables():
#     print(v.name, v.varValue)